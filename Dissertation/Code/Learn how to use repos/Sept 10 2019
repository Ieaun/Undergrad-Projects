#!/usr/bin/env python
# Code altered by IEAUN ROBERTS of the University of Hull 2018-2019
# -*- coding: utf-8 -*-
#
#     ||          ____  _ __
#  +------+      / __ )(_) /_______________ _____  ___
#  | 0xBC |     / __  / / __/ ___/ ___/ __ `/_  / / _ \
#  +------+    / /_/ / / /_/ /__/ /  / /_/ / / /_/  __/
#   ||  ||    /_____/_/\__/\___/_/   \__,_/ /___/\___/
#
#  Copyright (C) 2011-2013 Bitcraze AB
#
#  Crazyflie Nano Quadcopter Client
#
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.

#  You should have received a copy of the GNU General Public License along with
#  this program; if not, write to the Free Software Foundation, Inc.,
#  51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""
The console tab is used as a console for printouts from the Crazyflie.
"""
import logging
from dbm import error
from multiprocessing.util import Finalize

from PyQt5 import uic
from PyQt5.QtCore import pyqtSignal
# noinspection PyUnresolvedReferences
from PyQt5.QtWidgets import QMessageBox
from socket import socket, gethostbyname, AF_INET , SOCK_DGRAM , error
import sys
import select

from pyqtgraph.console import Console

from cfclient.ui.tabs import ConsoleTab
from dbus.server import Server
from ufw.util import msg

import cfclient
from cfclient.ui.tab import Tab
# noinspection PyUnresolvedReferences
import cflib.crtp
# noinspection PyUnresolvedReferences
from cfclient.utils.input.inputreaderinterface import InputData
from cfclient.utils.logconfigreader import LogConfig
from cflib.crazyflie.log import LogConfig , Log
# noinspection PyUnresolvedReferences
from cfclient.utils.logconfigreader import LogVariable
# noinspection PyUnresolvedReferences
from cflib.crazyflie import Crazyflie, Console
# noinspection PyUnresolvedReferences
from cflib.crazyflie.param import Param
logging.basicConfig(level=logging.DEBUG)

import time
import numpy as np
from numpy import zeros
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import axes3d
import matplotlib.ticker as plticker
import datetime
from datetime import timedelta
import struct
import os
import psutil

try:
    import zmq
except ImportError as e:
    raise Exception("ZMQ library probably not installed ({})".format(e))

__author__ = 'Bitcraze AB and Ieaun Roberts'
__all__ = ['ConsoleTab']

logger = logging.getLogger(__name__)

console_tab_class = uic.loadUiType(cfclient.module_path +
                                   "/ui/tabs/consoleTab.ui")[0]

class ConsoleTab(Tab, console_tab_class):
    """Console tab for showing printouts from Crazyflie"""
    _connected_signal = pyqtSignal(str)
    _disconnected_signal = pyqtSignal(str)
    _log_data_signal: pyqtSignal = pyqtSignal(int, object, object)
    _log_error_signal = pyqtSignal(object, str)
    _param_updated_signal = pyqtSignal(str, str)
    _update = pyqtSignal(str)

    SendCommands_Test = False                                   # Set to false in order to deactivate send commands
    activate_UDP_Test = True                                   # When False program does not connect to udp stream, sets all UDP values to -1
    LogSpeed = 20                                              #Set how fast the client communicates with the drone in ms
    RateofCommandsLogged = 5
    Trim_Pitch =  0.9
    Trim_Roll = -0.3

    dataBlockSize = 1024 #/512 #/256                            # Size of UDP blocks recieved by Vicon

    TransPositions = zeros([3,10])                      #holds 3 raw Trans values
    AveragedTransPositions = [0,0,0]
    RotPositions = zeros([3,10])
    AveragedRotPositions = [0,0,0]

    LockAxis = [-1,-1,-1]                               #Used to work with indivdual origin axis values

    ThrustValues= []                                    #Holds every 10th thrust value
    ThrustIntegrationCounter = 0

    Counter = 0                                         #Counter used to hold udp data

    PIDInitialized = 0                                  #Tells PID controller if it needs to initialize
    ErrorTerms = [0, 0, 0, 0, 0, 0, 0, 0]               #Stores the error terms, 0= X , 1= Y, 2= Rotional Z, 3= Z,  4= PreviousX, 5=Previous Y, 6 Previous rotational Z, 7 =Previous Z
    Command = []                                        #Stores the commands,0-2 = 1st point, 3-5 = 2nd point, 6-8 = 3rd point

    PIDTuner =[0.5,0.0026,0.1], [0.0003,0.00003,0.02]#[0,05][41.4,3.6,117.4], [0.00075, 0.000017, 0.01 ]     # Used for Verticle thrust PID operations , USed for Gyro PID operations, [82.4,4.12,104.5], [0.0008 , 0.000017, 0.0013 ]

    hover_Speed = 46500                                          #If the integral sum allows a value higher than this it will never be able to hover

    Thrust_integral_Limiter = hover_Speed / PIDTuner[0][1]

    Thrust_integral_Starter = hover_Speed / PIDTuner[0][1]
    Thrust_integral_Starter -= Thrust_integral_Starter *  0.0285  # multiply Higer = lower

    Clamp_V = [0, 0, 0, 0]  # If true then clamp the intergal sum stopping it from accumulating
    IntegralSum = [0, 0, Thrust_integral_Starter, 0]  # Running total of error used for forward,backward,left,right,thrust movement, initialize thrust integral sum to hover speed on start up

    MinimumThrust = -10000                                  # At this thrust the drone will drop, there is no need for it to be any lower as it will hard dive if lower
    MaxThrust = 50000                                    # This tells the clamp in the integral arm not to allow any thrust over this amount (Hardware on CF2.0 is limited to 60000)
    Max_Min_P = 1.3
    Max_Min_R = 0.7
    Max_Output = [Max_Min_P, Max_Min_R, MaxThrust ,0.7]                             # Gyro values will never be more that these constan Pitch,ROll,Thrust,Yaw
    Min_Output = [-Max_Min_P, -Max_Min_R,  MinimumThrust ,-0.7]

    K_Outputs = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ,0 ,0]                #Holds the outputs for the Gyro PID operations [0-2 = Roll, 3-5 = Pitch , 6-8 = Yaw]
    PID_Output =[0, 0, 0, 0]                                         #Holds the final commands to be sent to the drone

    GyroValues = [0,0,0,0]                                #Roll,Pitch,0,Yaw

    ComCounter = 0                                      #Holds the amount of commands sent to the drone
    StartTime = datetime.datetime.now()
    current_Time = 0
    Time_log = []

    # Creates a list containing 5 lists, each of 8 items, all set to 0
    LogDataz = [[0 for x in range(8)] for y in range(60)]               # Holds all the data used in Summary to visualize changes in values
    LogDataz_Counter = 0

    Stage = 0                                                       # Stage 0 = lift off, Stage 1 = position alterations,
    LiftOffSpeed = 0#51000                                          # Constant used for thrust throguhtout
    LiftOffSpeedDuration = 5                                      # How many times to send the lift of command of Thrust = LiftoffSpeed
    RateOfChange = [0,0,0,0]

    SudoValues = [0,0,LiftOffSpeed,0]                   #Holds the constants for the command positions so as not to leave all the work to the PID controller (Const + PID output = Output)

    Hold = [0,0,0,0]                                    #records if the drone is holding its position
    KpOutput_Array = []
    KiOutput_Array = []
    KdOutput_Array = []

    XPos = []
    YPos = []
    ZPos = []

    Kp_Past = [0,0,0,0]

    Integral_Clear = [0,0,0]   #[0= Pitch/ 1 = Roll], [Value] [stage]

    Integral_Drift_Pitch = [0,0]
    Integral_Drift_Roll = [0,0]

    inertia_Push = [0,0]

    def __init__(self, tabWidget, helper, *args):
        super(ConsoleTab, self).__init__(*args)
        self.setupUi(self)

        self.tabName = "Virtual Trajectory"
        self.menuName = "Virtual Trajectory Tab"
        self.tabWidget = tabWidget
        self._helper = helper

        # Always wrap callbacks from Crazyflie API though QT Signal/Slots
        # to avoid manipulating the UI when rendering it
        self._connected_signal.connect(self._connected)
        self._disconnected_signal.connect(self._disconnected)
        self._update.connect(self.printText)
        self._log_data_signal.connect(self._log_data_recieved)
        self._param_updated_signal.connect(self._param_updated)

        self._helper.cf.console.receivedChar.add_callback(self._update.emit)
        self._helper.cf.connected.add_callback(self._connected_signal.emit)
        self._helper.cf.disconnected.add_callback(
            self._disconnected_signal.emit)

        self._clearButton.clicked.connect(self.clear)
        self.BtnConnect.clicked.connect(self.VTActivator)
        self._dumpSystemLoadButton.clicked.connect(
            lambda enabled:
            self._helper.cf.param.set_value("system.taskDump", '1'))
        self._propellerTestButton.clicked.connect(
            lambda enabled:
            self._helper.cf.param.set_value("health.startPropTest", '1'))
        #self.BtnEnter.clicked.connect(self.ThrustCommand)
        self.BtnEnterZMQ.clicked.connect(self.ZMQCommand)
        self.LoggerTest.clicked.connect(self.Ramp)
        self.btnSummary.clicked.connect(self.Summary)
        self.btnKill.clicked.connect(self.kill)
        self.RBTestMode.clicked.connect(self.ActivateTestMode)


    def ActivateTestMode(self):
        if self.RBTestMode.isChecked():
            ConsoleTab.SendCommands_Test = False
            self.console.insertPlainText("\n SendCommands set to False\n")
        else:
            ConsoleTab.SendCommands_Test = True
            self.console.insertPlainText("\n SendCommands set to True\n")


    def _connected(self, link_uri):
        """Callback when the Crazyflie has been connected"""
        self._dumpSystemLoadButton.setEnabled(True)
        self._propellerTestButton.setEnabled(True)
        self.BtnEnterZMQ.setEnabled(True)
        self.lblStatus.setText("Connected")

        if ConsoleTab.SendCommands_Test == False:
            self.console.insertPlainText("**Warning** \nCommands will not be sent\nTesting mode")


        """Enable all the panels"""
        self.groupBox_3.setEnabled(True)
        self.groupBox.setEnabled(True)
        self.GBZMQ.setEnabled(True)
        self.BtnConnect.setEnabled(False)
        self.GBPIDV.setEnabled(False)
        self.RB1Dimen.setEnabled(True)

        self.TEDZ.setEnabled(True)
        self.TEDX.setEnabled(True)
        self.TEDY.setEnabled(True)


        self.TxtThrust.setEnabled(True)
        self.txtHover.setEnabled(True)
        self.Move_Left_Box.setEnabled(True)
        self.Move_Right_Box.setEnabled(True)
        self.btnSummary.setEnabled(False)

        self.txtHover.clear()
        self.txtHover.insertPlainText(str(ConsoleTab.hover_Speed))

        if ConsoleTab.SendCommands_Test == True:
            Bool_Holder = False
        else:
            Bool_Holder = True

        self.RBTestMode.setChecked(Bool_Holder)

        temp_conf = LogConfig("Ieaun Sensor", ConsoleTab.LogSpeed)
        temp_conf.add_variable("baro.temp")
        temp_conf.add_variable("stabilizer.roll")
        temp_conf.add_variable("stabilizer.pitch")
        temp_conf.add_variable("stabilizer.yaw")
        temp_conf.add_variable("stabilizer.thrust")

        self._helper.cf.commander.set_client_xmode(False)  # True)
        self.DeactiveThrustProtection()  # Deactivate thrust protection

        self._helper.cf.log.add_config(temp_conf)
        if temp_conf.valid:
            temp_conf.data_received_cb.add_callback(self._log_data_signal.emit)
            temp_conf.start()


    def _disconnected(self, link_uri):
        """Callback for when the Crazyflie has been disconnected"""
        self.progressBar.setValue(0)
        self.lblThrusty.setText("0")

        """Memo"""
        self._dumpSystemLoadButton.setEnabled(False)
        self._propellerTestButton.setEnabled(False)

        """ Status """
        self.lblStatus.setText("Disconnected")
        self._temp_c.setText("0")
        self._temp_f.setText("0")
        self.lblThrustValue.setText("0")

        """ Directional Information """
        self.lblPitchValue.setText("0 +({})".format(str(ConsoleTab.Trim_Pitch)))
        self.lblYawValue.setText("0")
        self.lblRollValue.setText("0 +({})".format(str(ConsoleTab.Trim_Roll)))

        """ ZMQ """
        self.BtnEnterZMQ.setEnabled(False)
        self.TEDPitch.clear()
        self.TEDRoll.clear()
        self.TEDThrust.clear()
        self.TEDYaw.clear()
        self.progressBar.setValue(0)

        """ Testing"""
        self.YawV.setText("0")
        self.PitchV.setText("0")
        self.RollV.setText("0")

        """UDP / Virtual trajectory"""
        self.UDPCOnnectStatus.setText("Disconnected")
        self.UDPX.setText("0")
        self.UDPY.setText("0")
        self.UDPZ.setText("0")
        self.lblItemName.setText("None")
        self.UDPCOnnectStatus.setText("Socket Not Found")
        self.RBConnectUDP.setChecked(False)

        """disable all the panels"""
        self.groupBox_3.setEnabled(False)
        self.groupBox.setEnabled(False)
        self.GBZMQ.setEnabled(False)

        #PID
        self.GBPIDV.setEnabled(False)
        self.initPID()
        self.GBPIDV.setEnabled(False)
        self.RB1Dimen.setChecked(False)


    def initPID(self):
        self.GBPIDV.setEnabled(True)
        self.lblKp.setText("0")
        self.lblKi.setText("0")
        self.lblKd.setText("0")
        self.lblKi_2.setText("0")
        self.cb_clamp.setChecked(False)
        self.lblE_X.setText("0")
        self.lblE_Y.setText("0")
        self.lblE_Z.setText("0")

        self.lblThrustCmd.setText("0")
        self.lblE_X_2.setText("0")
        self.lblE_Y_2.setText("0")
        self.lblE_Z_2.setText("0")

        self.lblE_X_3.setText("0")
        self.lblE_Y_3.setText("0")
        self.lblE_Z_3.setText("0")

        self.UDPTX.setText("0")
        self.UDPTY.setText("0")
        self.UDPTZ.setText("0")

        self.lblKp_G_2.setText("0")
        self.lblKi_G_2.setText("0")
        self.lblKd_G_2.setText("0")
        self.lblThrustCmd_G.setText("0")
        self.lblThrustCmd_G_2.setText("0")
        self.lblKp_G_3.setText("0")
        self.lblKi_G_4.setText("0")
        self.lblKd_G_3.setText("0")
        self.btnSummary.setEnabled(False)

        self.lblCMDFThrust.setText("0")
        self.lblFPitchCom.setText("0")
        self.lblfYawCom.setText("0")
        self.lblfRollCom.setText("0")


        self.Direction_console.clear()
        self.Direction_console_P.clear()
        self.Direction_console_3.clear()

        self.progressBar2.setValue(0)


        ConsoleTab.Command = [int(self.TEDX.toPlainText())      ,int(self.TEDY.toPlainText())     ,int(self.TEDZ.toPlainText()),  0]

        ConsoleTab.ErrorTerms = [0, 0, 0, 0, 0, 0, 0, 0]  # Stores the error terms, 0= X , 1= Y, 2= Z, 3= PreviousX, 4=Previous Y, 5 =Previous Z

        ConsoleTab.PIDInitialized = 0
        #ConsoleTab.IntegralSum = 0
        ConsoleTab.K_Outputs = [0, 0, 0, 0, 0, 0, 0 , 0, 0, 0, 0, 0]
        #IntegralSum = [0, 0, ConsoleTab.Thrust_integral_Limiter, 0]
        ConsoleTab.ThrustValues = []
        ConsoleTab.ThrustIntegrationCounter = 0
        ConsoleTab.PID_Output = [0,0,0,0]
        ConsoleTab.ComCounter = 0
        ConsoleTab.LogDataz_Counter = 0
        ConsoleTab.LockAxis = [-1, -1, -1]
        self.lblComCounter.setText("0")
        ConsoleTab.Stage = 0


    def _log_data_recieved(self, timestamp, data, log_conf):
        """Callback when the log layer receives new data"""
        """logger.debug("{0}:{1}:{2}".format(timestamp, log_conf.name, data))"""
        self._temp_c.setText("{0:.2f}C".format(data["baro.temp"]))
        self._temp_f.setText("{0:.2f}C".format(data["baro.temp"] * 1.8 + 32))
        self.lblRollValue.setText("{0:.2f}".format(data["stabilizer.roll"]))
        self.lblPitchValue.setText("{0:.2f}".format(data["stabilizer.pitch"]))
        self.lblYawValue.setText("{0:.2f}".format(data["stabilizer.yaw"]))
        self.lblThrustValue.setText("{0:.2f}".format(data["stabilizer.thrust"]))

        Pitch = float(round((data["stabilizer.pitch"]), 1))                                                              #Trim Pitch (on my drone pitch needs to be trimmed, this may be due to damage to the gyro)
        Roll = float(round((data["stabilizer.roll"]), 1))
        Thrust = (data["stabilizer.thrust"])
        Yaw = int(round((data["stabilizer.yaw"]), 1))

        ConsoleTab.GyroValues[0] = Roll
        ConsoleTab.GyroValues[1] = Pitch
        ConsoleTab.GyroValues[3] = Yaw

        VTActivated = ConsoleTab.PIDInitialized                                                                         #determines if regualar opertion or VT activated
        #########
        if self.Off.isChecked() == False:
            self.LogTest2(Roll, Pitch, Yaw, Thrust)
        ########

        #########
        if self.RBConnectUDP.isChecked():
            UDPSocket = self.ConnectToUDPStream()
            self.UDPDataCoordinator(UDPSocket)
            if self.AveragedTransPositions[0]!= 0 and self.BtnConnect.isEnabled()!=True:                                                                    #initialized, Ready to begin virtual trajectory
                self.BtnConnect.setEnabled(True)
        else:
            self.UDPCOnnectStatus.setText("Socket Not Found")
        ##########

        ##########
        if VTActivated != 0:                                                                                            # If the Virtual trajectory has been initialized and should execute functions
            Stage = ConsoleTab.Stage
            if Stage == 0:
                self.LiftOff()

            elif Stage == 1:
                #### Start client PID loop ################################
                # Check if the drone has reached the setpoint, sets Error terms, Locks Axis to 1 Dimesnion
                Active = self.CommandCoordinator()
                # Alter values for Pitch,Roll,Thrust and Yaw via PID
                self.PIDHUB(Active)
                # Send the command to the drone
                self.SendCommand()

            elif Stage == 2:
                self.Land(0,0,0,ConsoleTab.PID_Output[2])
                if ConsoleTab.SendCommands_Test == False:
                    ConsoleTab.Stage = 3

            elif Stage == 3:
                self.SummaryP()

            else:
                self.console.insertPlainText("\n Done")

            # Update all lables and GUI items with new data
            self.UpdatePIDGUI()
            ###########


    #Over sees PID operations for each of the big 4 varables / Times out
    def PIDHUB(self,Active):

        ''' Active==:
            0 - (Pitch) Forwards / Backwards 1 indicates working with the X axis
            1 - (Roll) Left / Right 0 indicates working with the Y axis
            2 - (Thrust) UP / Down Verticle Movement Z axis
            3 - (Yaw) Rotation on Z axis '''

        if Active[2]:
            self.PID_Movement(2, 0)
            ConsoleTab.ThrustIntegrationCounter += 1
        if Active[0]:
            self.PID_Movement(0, 1)
        if Active[1]:
            self.PID_Movement(1, 1)
        if False:#Active[3]:
            self.PID_Movement(3, 1)

        # Increase thrust proportional to the Roll and Pitch command
        #self.Thrust_Proportional_Increase()

        if ConsoleTab.ComCounter >= 1300:  # Time out and display memory usage
            Process = psutil.Process(os.getpid())
            self.console.insertPlainText("\n \nMemory Usage :\n"+str(Process.memory_info().rss / 1000000) +" Mb\n")
            ConsoleTab.Stage = 2
            self.console.insertPlainText("Time Out")


    # This method increases thrust propotionally to the amount of Pitch / Roll being requested
    def Thrust_Proportional_Increase(self):
        '''Purpose: Higer Pitch / Roll commands result in individually lower torque from a designated
                    motor which in turn decreases thurst. This method increases thrust propotionally
                    to the amount of Pitch / Roll being requested'''

        Pitch_Increase = self.ProportionalArm(ConsoleTab.PID_Output[0],150)
        Roll_Increase = self.ProportionalArm(ConsoleTab.PID_Output[1], 150)
        #Yaw_Increase = self.ProportionalArm(ConsoleTab.PID_Output[3], 300)

        # add increase to Thrust output
        ConsoleTab.PID_Output[2] += Pitch_Increase + Roll_Increase


    # Set all the Error term values
    def SetError(self):
        ''' Each variable has a present and past error term
            ErrorTerms[0 and 4] = Pitch  which relies on Trans X postion
            ErrorTerms[1 and 5] = Roll   which relies on Trans Y postion
            ErrorTerms[2 and 6] = Thrust which relies on Trans Z postion
            ErrorTerms[3 and 7] = Yaw    which relies on Rotational Z position

            This [0] = Pitch, [1] = Roll index convention is used throughout
            with numerious data structures

            Old Error term [i+4] = Previous Error Term [i]
            New Error terms = the desired position - the current measure position'''

        # Set PreviousError = errorTerm
        ConsoleTab.ErrorTerms[4] = ConsoleTab.ErrorTerms[0]
        ConsoleTab.ErrorTerms[5] = ConsoleTab.ErrorTerms[1]
        ConsoleTab.ErrorTerms[6] = ConsoleTab.ErrorTerms[2]
        ConsoleTab.ErrorTerms[7] = ConsoleTab.ErrorTerms[3]

        ConsoleTab.ErrorTerms[0] = int(ConsoleTab.Command[0]) - int(ConsoleTab.AveragedTransPositions[0])  # Trans X F/B Pitch
        ConsoleTab.ErrorTerms[1] = int(ConsoleTab.Command[1]) - int(ConsoleTab.AveragedTransPositions[1])  # Trans Y L/R Roll
        ConsoleTab.ErrorTerms[2] = int(ConsoleTab.Command[2]) - int(ConsoleTab.AveragedTransPositions[2])  # Thrust Z
        ConsoleTab.ErrorTerms[3] = int(ConsoleTab.Command[3]) - int(ConsoleTab.RotPositions[2, -1])    # Rotational Z Yaw

        # To be used in Derivative arm
        for i in range(4):
            ConsoleTab.Kp_Past[i] = ConsoleTab.K_Outputs[i*3]


    # Send command to increase the thrust to Liftoffspeed (taking Trim_Roll and Trim_Pitch into account)
    def lift_Off_NOPID(self):
        HoverSpeed = ConsoleTab.SudoValues[2]   # Get Speed
        ConsoleTab.ComCounter += 1

        if ConsoleTab.SendCommands_Test:
            self._helper.cf.commander.send_setpoint(ConsoleTab.Trim_Roll, ConsoleTab.Trim_Pitch, 0, HoverSpeed)
            self.lblThrusty.setText(str(HoverSpeed))
            self.progressBar.setValue(int((HoverSpeed / 60000) * 100))

        if ConsoleTab.ComCounter == ConsoleTab.LiftOffSpeedDuration:
            ConsoleTab.Stage = 1


    # Send command to increase the thrust using PID (taking Trim_Roll and Trim_Pitch into account)
    def LiftOff(self):

        ''' Purpose: Due to the alternative effects present when first lifting off
            from the ground which cause the drone to immediatly move around while
            the PID adjusts, This Function locks Pitch and Roll to values that
            stabilize the drone on lift off, this anomoly could be due to weight of
            markers unevely distibuted, regardless of cause, it is nessesary'''

        ConsoleTab.ComCounter += 1

        # Set error terms
        self.SetError()

        # Update Thrust value
        self.PID_Movement(2, 0)
        HoverSpeed = ConsoleTab.PID_Output[2]  # Get Speed

        Roll = ConsoleTab.Trim_Roll
        Pitch =  ConsoleTab.Trim_Pitch

        if ConsoleTab.SendCommands_Test:
            self._helper.cf.commander.send_setpoint(-Roll, Pitch , 0, HoverSpeed)
            self.add_Thrust_Log()

        if ConsoleTab.ComCounter == ConsoleTab.LiftOffSpeedDuration:
            ConsoleTab.Stage = 1


    # Lock Axis if only 1 dimensional flight
    def LockAxis_Method(self):
            ConsoleTab.LockAxis[0] = ConsoleTab.AveragedTransPositions[0]
            ConsoleTab.LockAxis[1] = ConsoleTab.AveragedTransPositions[1]
            # ConsoleTab.PIDTuner_Gyro =  [ConsoleTab.PIDTuner_Gyro[0]/3,ConsoleTab.PIDTuner_Gyro[1]/3,ConsoleTab.PIDTuner_Gyro[2]/3]
            ConsoleTab.Command[0] = ConsoleTab.LockAxis[0]
            ConsoleTab.Command[1] = ConsoleTab.LockAxis[1]
            self.console.insertPlainText("\n Axis x and y locked to \n X:" + str(round(ConsoleTab.Command[0], 3)) + " Y:" + str(round(ConsoleTab.Command[1], 3)))


    # Kill drone if it has flipped / is flying too high
    def SaftyCheck(self):
        Pitch = int(ConsoleTab.GyroValues[0])
        Roll = int(ConsoleTab.GyroValues[1])
        if (Pitch > 20 or Pitch < -20) or (Roll > 20 or Roll < -20):
           ConsoleTab.Stage = 2
           self.console.insertPlainText("\nFlip Kill \nPitch:{}\nRoll:".format(str(Pitch),str(Roll)))
           ConsoleTab.PID_Output[2] = 0

        #If it flies up too high
        if ConsoleTab.TransPositions[2,-1] != 0:
                if ConsoleTab.TransPositions[2,-1] > 1800 :
                    ConsoleTab.Stage = 2
                    self.console.insertPlainText("Flew too close to the sun")


    # Determine if we are in the right positon
    def PositionVerify(self,ArmActive):
        ArmActive = [True,True,True,True]
        # for i in range(4):
        #     if ConsoleTab.ErrorTerms[i] <= 25 and ConsoleTab.ErrorTerms[i] >= -25:  # If drone is in position then +1
        #         ConsoleTab.Hold[i] += 1
        #         if ConsoleTab.Hold[i] == 50000000000000000000000:  # If drone in position for 5 clicks then we can confirm
        #             ArmActive[i] = False  # That it is in the correct position and move to next stage
        #             if i == 0:
        #                 self.RBX.setChecked(True)
        #             elif i == 1:
        #                 self.RBY.setChecked(True)
        #             elif i == 2:
        #                 self.RBZ.setChecked(True)
        #     else:
        #         ArmActive[i] = True
        #         ConsoleTab.Hold[i] = 0
        # return ArmActive
        return ArmActive


    #Checks if the VT is completed, Locks Axis to 1 Dimension, Sets Error terms
    def CommandCoordinator(self):
        ArmActive = [True, True, True, True]
        Stage = ConsoleTab.Stage

        # Kill drone if it has flipped
        self.SaftyCheck()

        # Lock Axis if only 1 dimensional flight
        if self.RB1Dimen.isChecked() == True and ConsoleTab.LockAxis[0] == -1:
            self.LockAxis_Method()

        # Set error terms
        self.SetError()

        for i in range(2):
            # reduce drift
            self.StopDrift(i)


        if False:
            # Determine if we are in the right positon
            ArmActive = self.PositionVerify(ArmActive)

            # If error is decreasing then no need to alter Pitch and Roll, This greatly decreases overshoot at the cost of constant control
            if ConsoleTab.ComCounter >= 200:
                ArmActive[0] = self.error_is_Decreasing(ConsoleTab.ErrorTerms[0],ConsoleTab.ErrorTerms[4],ArmActive[0])
                ArmActive[1] = self.error_is_Decreasing(ConsoleTab.ErrorTerms[1], ConsoleTab.ErrorTerms[5],ArmActive[0])

        return ArmActive


    # save integral sum value ,Empty integral, send command of integral sum = 0, then send command of inverse of previous integral sum to cancel out any present force
    def StopDrift(self,i):
        #Get List
        if i == 0:
            DataSet = ConsoleTab.Integral_Drift_Pitch
        else:
            DataSet = ConsoleTab.Integral_Drift_Roll


        if DataSet[0] == 0:
            # Empty integral sum of Pitch or roll if error is small enough
            DataSet = self.ClearIntegral(DataSet,i)

        elif  DataSet[0] <= 40 and DataSet[0] != 0:
            ConsoleTab.IntegralSum[i] = DataSet[1]
            DataSet[0]+= 1

        else:
            ConsoleTab.inertia_Push[i] = 0
            ConsoleTab.IntegralSum[i] = 0
            DataSet[0] = 0
            DataSet[1] = 0

        #Set list
        if i == 0:
            ConsoleTab.Integral_Drift_Pitch = DataSet
        else:
            ConsoleTab.Integral_Drift_Roll = DataSet


    # if error term is small enough, set integral sum to 0
    def ClearIntegral(self,DataSet,i):

        if ConsoleTab.ErrorTerms[i] < 25 and ConsoleTab.ErrorTerms[i] > -25:
            DataSet[1] = ConsoleTab.IntegralSum[i] * -1       #value
            ConsoleTab.inertia_Push[i] = (DataSet[1] * 0.75) * ConsoleTab.PIDTuner[1][1]
            DataSet[0] = 1                                    #Stage
            ConsoleTab.IntegralSum[i] = 0

        return DataSet


    #Determines if arm can be deactivated due to drone already moving towards Error=0
    def error_is_Decreasing(self,current_Error,previous_Error,ArmActive):
        '''Returns false if the arm should be deactivated'''
        if current_Error < previous_Error and previous_Error > 0:
            ArmActive = False
        elif current_Error > previous_Error and previous_Error < 0:
            ArmActive = False
        else:
            ArmActive = ArmActive
        return ArmActive


    #deactivate drone and Initialize all PID variables
    def kill(self):
        self.DeactiveThrustProtection()
        self.EndCommand()
        self.RBConnectUDP.setChecked(False)
        self.RB1Dimen.setChecked(False)
        ConsoleTab.Stage = 2
        self.initPID()


    # Send command to drone
    def SendCommand(self):
        ConsoleTab.ComCounter += 1
        Counter = ConsoleTab.ComCounter

        #Get Commands
        Thrust, Pitch ,Roll , Yaw = self.FormatCommand(Counter)

        #Calcuate time
        self.work_Out_Time()
        Rate = Counter / ConsoleTab.current_Time
        self.lblComCounter_2.setText(str(round(Rate,1)) + " Cmd/s")

        # Write data to file
        if Counter % ConsoleTab.RateofCommandsLogged == 0:
            self.FormatForLOGData(Roll,Pitch,0,Thrust)

        # Safety check
        if len(ConsoleTab.ThrustValues) > 4:
            PreThrust = ConsoleTab.ThrustValues[-2]
        else:
            PreThrust = Thrust

        # IF this is the case then something stange has happended causing the drone to free fall
        # This saves it and tells it to land
        if (PreThrust - 10000 > Thrust) and Counter > 100:
            ConsoleTab.Stage = 2
            self.console.insertPlainText("\n\nEmergency landing activated \nStats \nPrevious thrust:{} \nCurrent thrust :{} \nCurrent Integral output :{} \nCurrent Proportional output :{} \nDerivative :{}".format(str(PreThrust),str(Thrust),str(int(ConsoleTab.K_Outputs[7])),str(ConsoleTab.K_Outputs[6]),str(int(ConsoleTab.K_Outputs[8])) ))
            ConsoleTab.PID_Output[2]= PreThrust
        else:
            if Thrust< 0: Thrust = 0

            # Send command to drone
            if ConsoleTab.SendCommands_Test:
                self._helper.cf.commander.send_setpoint(-Roll, Pitch, 0, Thrust)
        return


    def FormatCommand(self,Counter):
        Thrust = int(ConsoleTab.PID_Output[2] + ConsoleTab.SudoValues[2])
        Pitch = round(ConsoleTab.PID_Output[0] + ConsoleTab.SudoValues[0], 1)
        Roll = round(ConsoleTab.PID_Output[1] + ConsoleTab.SudoValues[1], 1)
        # Yaw = round(ConsoleTab.Gyro_COmmands[3] + ConsoleTab.GyroValues[3],1)
        Yaw = round(ConsoleTab.PID_Output[3] + ConsoleTab.SudoValues[3],1)  # If you ensure the drone is facing Rot = 0 on Z axis

        # Then ignore translation of commands according to Yaw angle
        Pitch += ConsoleTab.Trim_Pitch
        #Roll += ConsoleTab.Trim_Roll

        # Push to overcome inertia
        Roll += ConsoleTab.inertia_Push[1]
        Pitch += ConsoleTab.inertia_Push[0]


        self.lblCMDFThrust.setText(str(Thrust))
        self.lblFPitchCom.setText(str(Pitch))
        self.lblfRollCom.setText(str(Roll))
        self.lblfYawCom.setText(str(Yaw))
        self.lblComCounter.setText(str(Counter))

        return Thrust, Pitch ,Roll , Yaw


    #Work out time difference between now and start
    def work_Out_Time(self):
        StartTime = ConsoleTab.StartTime  # Get start time
        Currenttime = datetime.datetime.now()
        Time = Currenttime - StartTime  # Start time - current time
        Tim_D = Time / timedelta(seconds=1)
        ConsoleTab.current_Time = Tim_D


    def add_Thrust_Log(self):
        ConsoleTab.KpOutput_Array.append(ConsoleTab.K_Outputs[6])
        ConsoleTab.KiOutput_Array.append(ConsoleTab.K_Outputs[7])
        ConsoleTab.KdOutput_Array.append(ConsoleTab.K_Outputs[8])

        ConsoleTab.XPos.append(ConsoleTab.AveragedTransPositions[0])
        ConsoleTab.YPos.append(ConsoleTab.AveragedTransPositions[1])
        ConsoleTab.ZPos.append(ConsoleTab.AveragedTransPositions[2])

        ConsoleTab.ThrustValues.append(ConsoleTab.PID_Output[2])
        ConsoleTab.Time_log.append(ConsoleTab.current_Time)


    #Format the data properly before it is written to a textfile
    def FormatForLOGData(self,Roll,Pitch,Yaw,Thrust):
        self.add_Thrust_Log()

        if ConsoleTab.LogDataz_Counter == 59:
            #Thrust
            Thrust = str(Thrust) + " Time:" + str(ConsoleTab.current_Time)
            Err1 = str(ConsoleTab.ErrorTerms[2]) + " Prev:" + str(ConsoleTab.ErrorTerms[6])+ " Kp:" + str(ConsoleTab.K_Outputs[6]) +" Ki:" + str(ConsoleTab.K_Outputs[7]) + " KiS:" + str(ConsoleTab.IntegralSum[2]) + " Kd:" + str(ConsoleTab.K_Outputs[8])
            #Pitch
            Err2 = str(ConsoleTab.ErrorTerms[0]) + " Prev:" + str(ConsoleTab.ErrorTerms[4]) + " Kp:" + str(ConsoleTab.K_Outputs[0]) +" Ki:" + str(ConsoleTab.K_Outputs[1]) + " KiS:" + str(ConsoleTab.IntegralSum[0]) + " Kd:" + str(ConsoleTab.K_Outputs[2])
            #Roll
            Err3 = str(ConsoleTab.ErrorTerms[1]) + " Prev:" + str(ConsoleTab.ErrorTerms[5]) + " Kp:" + str(ConsoleTab.K_Outputs[3]) +" Ki:" + str(ConsoleTab.K_Outputs[4]) + " KiS:" + str(ConsoleTab.IntegralSum[1]) + " Kd:" + str(ConsoleTab.K_Outputs[5])
            #Yaw
            Err4 = str(ConsoleTab.ErrorTerms[3]) + " Prev:" + str(ConsoleTab.ErrorTerms[7]) + " Kp:" + str(ConsoleTab.K_Outputs[9]) +" Ki:" + str(ConsoleTab.K_Outputs[10]) + " KiS:" + str(ConsoleTab.IntegralSum[3]) + " Kd:" + str(ConsoleTab.K_Outputs[11])
            NewData = [Thrust , Err1, Roll, Err3, Pitch, Err2, Yaw, Err4]
            ConsoleTab.LogDataz = self.SlidingWindow_Simple_Numpy(ConsoleTab.LogDataz, NewData,len(ConsoleTab.LogDataz))
        else:
            ConsoleTab.LogDataz[ConsoleTab.LogDataz_Counter][0] = str(Thrust) + " Time:" +str(ConsoleTab.current_Time)
            ConsoleTab.LogDataz[ConsoleTab.LogDataz_Counter][1] = str(ConsoleTab.ErrorTerms[2]) + " Prev:" + str(ConsoleTab.ErrorTerms[6]) + " Kp:" + str(ConsoleTab.K_Outputs[6]) +" Ki:" + str(int(ConsoleTab.K_Outputs[7])) +" KiS:" + str(ConsoleTab.IntegralSum[2]) + " Kd:" + str(ConsoleTab.K_Outputs[8])
            ConsoleTab.LogDataz[ConsoleTab.LogDataz_Counter][2] = str(Roll)
            ConsoleTab.LogDataz[ConsoleTab.LogDataz_Counter][3] = str(ConsoleTab.ErrorTerms[1]) + " Prev:" + str(ConsoleTab.ErrorTerms[5]) + " Kp:" + str(ConsoleTab.K_Outputs[3]) +" Ki:" + str(ConsoleTab.K_Outputs[4]) + " KiS:" + str(ConsoleTab.IntegralSum[1]) + " Kd:" + str(ConsoleTab.K_Outputs[5])
            ConsoleTab.LogDataz[ConsoleTab.LogDataz_Counter][4] = str(Pitch)
            ConsoleTab.LogDataz[ConsoleTab.LogDataz_Counter][5] = str(ConsoleTab.ErrorTerms[0]) + " Prev:" + str(ConsoleTab.ErrorTerms[4]) + " Kp:" + str(ConsoleTab.K_Outputs[0]) +" Ki:" + str(ConsoleTab.K_Outputs[1]) + " KiS:" + str(ConsoleTab.IntegralSum[0]) + " Kd:" + str(ConsoleTab.K_Outputs[2])
            ConsoleTab.LogDataz[ConsoleTab.LogDataz_Counter][6] = str(Yaw)
            ConsoleTab.LogDataz[ConsoleTab.LogDataz_Counter][7] = str(ConsoleTab.ErrorTerms[3]) + " Prev:" + str(ConsoleTab.ErrorTerms[7]) +  " Kp:" + str(ConsoleTab.K_Outputs[9]) +" Ki:" + str(ConsoleTab.K_Outputs[10]) + " KiS:" + str(ConsoleTab.IntegralSum[3]) + " Kd:" + str(ConsoleTab.K_Outputs[11])
            ConsoleTab.LogDataz_Counter += 1


    #Handles flight controller pannel
    def LogTest2(self, Roll, Pitch, Yaw, Thrust):
        '''This function is very useful (More specifically the hover area)
           when readjusting the pitch / roll trim when drone motion capture
           marker calibration has changed.
           First begin with adjusting thrust to get a stable hover speed then
           adjust the ROll and pitch trim until you mangae to get a stable lift off'''

        self.RollV.setText(str(Roll))
        self.PitchV.setText(str(Pitch))
        self.YawV.setText(str(Yaw))

        #Deactivate thrust protection
        if self.LoggingLock.isChecked():
            self._helper.cf.commander.send_setpoint(0, 0, 0, 0)

        #Rize
        if self.StartLog.isChecked():
            Yaw = 0 #Yaw is irrelavant for now
            Thrustest =int(self.TxtThrust.toPlainText()) #Get Speed
            self.progressBar.setValue(int((Thrustest / 60000) * 100))

            if Thrustest <= 60000 and Thrustest > 10000:
                if ConsoleTab.SendCommands_Test:
                    self._helper.cf.commander.send_setpoint(-Roll, Pitch, Yaw, Thrustest)

                self.lblThrusty.setText(str(Thrustest))

        #Land (Locks controls)
        if self.LandLog.isChecked() :
            currentThrust = int(self.lblThrusty.text())
            self.Land(Roll,Pitch,Yaw,currentThrust)

        #Hover
        if self.RBHover.isChecked():
            self.alter_PandR()  #Calls movement or auto pilot

            ConsoleTab.hover_Speed = int(self.txtHover.toPlainText())
            HoverSpeed = ConsoleTab.hover_Speed  # Get Speed
            self.progressBar.setValue(int((HoverSpeed / 60000) * 100))
            if ConsoleTab.SendCommands_Test:
                self._helper.cf.commander.send_setpoint(-(ConsoleTab.PID_Output[1]), ConsoleTab.Trim_Pitch + ConsoleTab.PID_Output[0], 0, HoverSpeed)
            self.lblThrusty.setText(str(HoverSpeed))

        return


    #Alter Pitch and Roll
    def alter_PandR(self):
        if self.Auto_Pilot.isChecked():
            self.auto_Pilot()

        elif self.move_Left.isChecked():
            self.move_Left.setChecked(False)
            ConsoleTab.SudoValues[1] += float(self.Move_Left_Box.toPlainText())

        elif self.move_Right.isChecked():
            self.move_Right.setChecked(False)
            ConsoleTab.SudoValues[1] -= float(self.Move_Left_Box.toPlainText())

        elif self.move_Forw.isChecked():
            self.move_Forw.setChecked(False)
            ConsoleTab.SudoValues[0] += float(self.Move_Left_Box.toPlainText())

        elif self.move_Back.isChecked():
            self.move_Back.setChecked(False)
            ConsoleTab.SudoValues[0] -= float(self.Move_Left_Box.toPlainText())
        else:
            Hello = 0


    #Allow the system to calculate the next Pitch and Roll command
    def auto_Pilot(self):
        ConsoleTab.Command = [0,0,0,0]

        self.SetError()

        for i in range(2):
            Prop = self.ProportionalArm(ConsoleTab.ErrorTerms[i],0.0026) #float(self.ManualMovement(Error_TermX))
            ConsoleTab.PID_Output[i],derivative_V = self.derivative_Arm(i,0.15,Prop)

            ConsoleTab.PID_Output[i],Changed = self.over_Limit(ConsoleTab.PID_Output[i],ConsoleTab.Max_Output[i],ConsoleTab.Min_Output[i])

            self.console.insertPlainText("\nNum{}  Error:{} Value:{} \nP:{} \nI: \nD:{}".format(str(i),str(ConsoleTab.ErrorTerms[i]),str(ConsoleTab.PID_Output[i]),str(Prop),str(derivative_V) ))
        self.console.insertPlainText("\n")


    #Update the GUI with new PID values
    def UpdatePIDGUI(self):
        self.btnSummary.setEnabled(True)

        Thrust = ConsoleTab.PID_Output[2]
        self.lblCMDFThrust.setText(str(Thrust))
        self.progressBar.setValue((Thrust / 60000) * 100)
        self.lblThrusty.setText(str(Thrust))

        if self.RBTh.isChecked():
            #Counter = ConsoleTab.Acounter - 1

            # Position
            self.lblE_X_2.setText(str(int(ConsoleTab.AveragedTransPositions[0])))
            self.lblE_Y_2.setText(str(int(ConsoleTab.AveragedTransPositions[1])))
            self.lblE_Z_2.setText(str(int(ConsoleTab.AveragedTransPositions[2])))

            ET = ConsoleTab.ErrorTerms

            # Error Terms
            self.lblE_X.setText(str(ET[0]))
            self.lblE_Y.setText(str(ET[1]))
            self.lblE_Z.setText(str(ET[3]))

            # PID outputs
            self.lblKp.setText(str(ConsoleTab.K_Outputs[6]))
            self.lblKi.setText(str(ConsoleTab.K_Outputs[7]))
            self.lblKd.setText(str(ConsoleTab.K_Outputs[8]))

            # Integral sum
            self.lblKi_2.setText(str(ConsoleTab.IntegralSum[2]))

            # Clamp
            self.cb_clamp.setChecked(bool(ConsoleTab.Clamp_V[2]))

            # Thrustcmd
            self.lblThrustCmd.setText(str(Thrust))


            if len(ConsoleTab.ThrustValues) > 2:
                if ConsoleTab.ThrustValues[-2] < ConsoleTab.ThrustValues[-1]:
                    self.Direction_console.setText("    ^" + "\n" + "    |")  # UP
                else:
                    self.Direction_console.setText("   |" + "\n" + "   V")  # Down

        if self.RBPIT.isChecked():                                                                                      # Pitch
            self.lblKp_G_2.setText(str(round(ConsoleTab.K_Outputs[0], 2)))
            self.lblKi_G_2.setText(str(round(ConsoleTab.K_Outputs[1], 2)))
            self.lblKd_G_2.setText(str(round(ConsoleTab.K_Outputs[2], 2)))

            #TODO: Fix directional visualization
            if ConsoleTab.PID_Output[0] > float(self.lblThrustCmd_G.text()):
                self.Direction_console_P.setText("   ^")    #UP
            else:
                self.Direction_console_P.setText("   V") #Down
            self.lblThrustCmd_G.setText(str(ConsoleTab.PID_Output[0]))


        if self.RBROl.isChecked():                                                                                      # Roll
            self.lblKp_G_3.setText(str(round(ConsoleTab.K_Outputs[3], 2)))
            self.lblKi_G_4.setText(str(round(ConsoleTab.K_Outputs[4], 2)))
            self.lblKd_G_3.setText(str(round(ConsoleTab.K_Outputs[5], 2)))

            # TODO: Fix directional visualization
            if ConsoleTab.PID_Output[1] > float(self.lblThrustCmd_G.text()):
                self.Direction_console_3.setText("<--")
            else:
                self.Direction_console_3.setText("-->")
            self.lblThrustCmd_G_2.setText(str(ConsoleTab.PID_Output[1]))

        if self.RBYAW.isChecked():
            # Rotation
            self.lblE_X_3.setText(str(int(round(ConsoleTab.RotPositions[0, -1], 0))))
            self.lblE_Y_3.setText(str(int(round(ConsoleTab.RotPositions[1, -1], 0))))
            self.lblE_Z_3.setText(str(int(round(ConsoleTab.RotPositions[2, -1], 0))))

            self.lblKp_G_4.setText(str(round(ConsoleTab.K_Outputs[9], 2)))
            self.lblKi_G_3.setText(str(round(ConsoleTab.K_Outputs[10], 2)))
            self.lblKd_G_4.setText(str(round(ConsoleTab.K_Outputs[11], 2)))
            self.lblThrustCmd_G_3.setText(str(ConsoleTab.PID_Output[3]))


    def printText(self, text):
        # Make sure we get printouts from the Crazyflie into the log (such as
        # build version and test ok/fail)
        logger.debug("[%s]", text)
        self.console.insertPlainText(text)


    #Experimental basic movement translation to examine the effect of different output
    def ManualMovement(self,ErrorTerm):
        Output = 0
        Negative = False
        if ErrorTerm < 0:
            ErrorTerm = ErrorTerm *-1
            Negative = True

        if ErrorTerm <= 100:
            if ErrorTerm < 25:
                Output = 0.1
            elif ErrorTerm < 50:
                Output = 0.15
            elif ErrorTerm < 75:
                Output = 0.25
            elif ErrorTerm <= 100:
                Output = 0.5
            else:
                Output = 0.75
        else:
            if ErrorTerm < 200:
                Output = 1
            elif ErrorTerm <= 300:
                Output = 1.25
            else:
                Output = 1.5

        #if it was a negative then change it back to negative
        if Negative:
            Output *= -1

        return Output


    def clear(self):
        self.console.clear()


    # Set the gloabal variable values to the newly calculated PID output values
    def set_Outputs(self,Axis,proportionalV,integralV,derivativeV,OutputV):

        ''' K_Outputs [0-2] = X/Pitch
            K_Outputs [3-5] = Y/Roll
            K_Outputs [6-8] = Z/Thrust
            K_Outputs [9-11] = RotZ/Yaw
            e.g if axis = 2,      2*3 = 6,   K_Outputs[6-8] = thrust'''

        index = Axis * 3
        ConsoleTab.K_Outputs[index + 1] = round(integralV, 4)
        ConsoleTab.K_Outputs[index + 2] = round(derivativeV, 4)

        if Axis ==2:
            ConsoleTab.PID_Output[Axis] = int(OutputV)
        else:
            ConsoleTab.PID_Output[Axis] = round(OutputV, 4)


    # This calculates all movement (Forwards / backwards / left / right / up / down)
    def PID_Movement(self, Axis, Tune):
        ''' [1]*PROPORTIONAL*  Error x Kp
            Does what it says on the tin, Kp output is proportional to error
            in the system, more error = higher output, less error = lower

            [2]*INTEGRAL*  (Integral sum + error) x Ki
            sums up error in system to produce an output. The clamp checks
            if values are saturating (Intergral growing out of bounds)
            returns either 1 = dont clamp or 0 = clamp
            if clamping then dont add more error to the integral sum,
            if not clamping then continue to add error to integral sum

            [3]*DERIVATIVE* (Error - Previous Error) * Kd
            calculates the rate of change and either increases or decreases
            the overall output based upon wether the rate of change is
            shrinking (getting closer) (decrease) or
            growing (getting further away) (increase)

            Axis = 0 = Transitional X = Pitch  =  PIDTuner[0][i] = ErrorTerm[0 and 4] = Rate_O_Change[0] = IntegralSum[0]
            Axis = 1 = Transitional Y = Roll   =  PIDTuner[0][i] = ErrorTerm[1 and 5] = Rate_O_Change[1] = IntegralSum[1]
            Axis = 2 = Transitional Z = Thrust =  PIDTuner[1][i] = ErrorTerm[2 and 6] = Rate_O_Change[2] = IntegralSum[2]
            Axis = 3 = Rotational Z   = Yaw    =  PIDTuner[0][i] = ErrorTerm[3 and 7] = Rate_O_Change[3] = IntegralSum[3]
        '''

        #TODO: When the drone reaches an error of 0 on the Z axis it kills the inegral arm and sets it to 0

        ''' 1 '''
        proportional_v = self.ProportionalArm(ConsoleTab.ErrorTerms[Axis],ConsoleTab.PIDTuner[Tune][0])
        output_v = proportional_v
        ConsoleTab.K_Outputs[Axis * 3] = round(proportional_v, 4)
        #DOnt keep output_Value
        output_Value, activate_Integral = self.over_Limit(output_v,ConsoleTab.Max_Output[Axis],ConsoleTab.Min_Output[Axis])

        ''' 2 '''
        if activate_Integral:
            output_v, ConsoleTab.Clamp_V[Axis], integral_V, ConsoleTab.IntegralSum[Axis] = self.integral_Arm(ConsoleTab.ErrorTerms[Axis], ConsoleTab.IntegralSum[Axis], output_v, ConsoleTab.PIDTuner[Tune][1],ConsoleTab.Max_Output[Axis], ConsoleTab.Min_Output[Axis], Axis)
        else:
            #(Set to the previous value)
            self.console.insertPlainText("\n Integral off Axis:{}\n".format(str(Axis)))
            integral_V = ConsoleTab.K_Outputs[(Axis*3) + 1]
            output_v += integral_V

        ''' 3 '''
        output_v,derivative_V = self.derivative_Arm(Axis,ConsoleTab.PIDTuner[Tune][2],output_v)

        #Just in case an invalid thrust value sneaks in after derivative arm activation (output cannot be higher than Max output or lower than min output)
        output_v,Boolian_V = self.over_Limit(output_v,ConsoleTab.Max_Output[Axis],ConsoleTab.Min_Output[Axis])

        self.set_Outputs(Axis,proportional_v,integral_V,derivative_V,output_v)


    #IF Value is larger than Upper limit or Smaller than Lower limit then change value to said limit
    def over_Limit(self,Value,Limit_Upp, Limit_Low):
        '''If proportional is at limit already then dont use integral '''
        '''If integral sum is at limit then set to limit to stop windup'''
        Didnt_change = True

        if Value > 0 :
            if Value > Limit_Upp:
                Value = Limit_Upp
                Didnt_change = False
        else:
            if Value < Limit_Low:
                Value = Limit_Low
                Didnt_change = False

        return Value, Didnt_change


    def DerivativeRateofChange(self, Current_Error, previous_Error):
        if previous_Error == 0:
            rate_Of_Change = 0
        else:
            rate_Of_Change =  -1 + (Current_Error / previous_Error)
        return rate_Of_Change


    def derivative_Arm(self,Axis,Kd,output_v):
        rate_O_Change = self.DerivativeRateofChange(ConsoleTab.ErrorTerms[Axis], ConsoleTab.ErrorTerms[Axis + 4])

        if Axis == 2:
            if ConsoleTab.ErrorTerms[Axis] > 200 or ConsoleTab.ErrorTerms[Axis] < 200:
                derivative_V = (rate_O_Change) * Kd
            else:
                derivative_V = (rate_O_Change * Kd)

        else:
            derivative_V = (rate_O_Change * Kd)*-1

        ConsoleTab.RateOfChange[Axis] = rate_O_Change
        derivative_V, Booliana = self.over_Limit(derivative_V,2000,-2000)

        output_v += derivative_V
        return output_v,derivative_V


    def integral_Arm(self, error_Term, integral_Sum, Value, Ki, max_Val, min_Val, Axis):
        ''' Add error term to integral sum and calculate
            integral output.
            Test if final value needs to be clamped
            if clamp = 0 add value to sum, keep the test integral thrust
            if clamp = 1 uses previous integralSum and dont not new error value
            Thrust cannot be lower than 0'''

        pre_Value = Value + ((integral_Sum + error_Term) * Ki)
        Clamped, pre_Value = self.Clamp(pre_Value, max_Val, min_Val, error_Term, Axis)

        # No Clamp
        if  Clamped == 0 :
            integral_Sum += error_Term
            integral_Value = integral_Sum * Ki
            Value += integral_Value
        # Clamp
        elif Clamped == 1:
            integral_Value = integral_Sum * Ki
            Value += integral_Value

        return Value, Clamped, integral_Value, integral_Sum


    # the controller shuts down intergration if it is at maximal/ minimal value
    def Clamp(self, Value, max_Value, min_Value, error_Term, Axis):
        Saturating, signs_equal, out_Of_Bounds, thrust_Out_Of_Bounds = False, True, False, False
        current_Value = Value

        if Value >= max_Value:
            Value = max_Value
        elif Value <= min_Value:
            Value = min_Value


        '''if true then saturation taking place'''
        if current_Value != Value:
            Saturating = True
        else:
            Saturating = False

        if Axis == 2:
            ''' *Only used for Thrust as others make use of negative and pos integral sums*
               if both positive then integrator will increase, 
               if both negative then intergator will decrease
               if both same sign integrator makes better'''
            # if (Value > 0 and error_Term > 0): #or (Value < 0 and error_Term < 0):
            #     signs_equal = True

            '''If the integral sum for thrust goes over this it will never reach a stable state
               as it wont be able to hover, only acend due to the high integral output which will
               cause an overshoot that will be lowered by the proportional and then force it to enter an
               endless loop of overshooting '''
            integral_Sum = ConsoleTab.IntegralSum[Axis]
            if integral_Sum + error_Term > ConsoleTab.Thrust_integral_Limiter:
                thrust_Out_Of_Bounds = True

            # else:
            #     signs_equal = False

        else:

            '''All this code here does is limit the integral sum value for Roll, Pitch and Yaw 
               so that it does not over accumulate to ridiculous levels,'''
            integral_Sum_Limiter_High = 35000
            integral_Sum_Limiter_Low = integral_Sum_Limiter_High * -1
            integral_Sum = ConsoleTab.IntegralSum[Axis]

            # Limit the integral sum to 5000
            ConsoleTab.IntegralSum[Axis], Verdict = self.over_Limit(integral_Sum,integral_Sum_Limiter_High,integral_Sum_Limiter_Low)
            if Verdict:
                out_Of_Bounds = False
            else:
                out_Of_Bounds = True

                #If integral sum is -10000 and error it 100 then it is attempting to drive error out, so let it
                if (integral_Sum > 0 and error_Term < 0) or (integral_Sum < 0 and error_Term > 0):
                    out_Of_Bounds = False
                else:
                    out_Of_Bounds = True

        '''if saturating and attempting to make values worse then 
           intergator must be turned off'''
        counter = ConsoleTab.ComCounter
        if  signs_equal == False or Saturating or out_Of_Bounds or thrust_Out_Of_Bounds:
            return 1, Value  # turn integral sum integration off
        else:
            return 0, Value  # Keep integral sum integration on


    def ProportionalArm(self, error_Term, Kp):                                                                                                                                                          #Kp
        proportional_Output = error_Term * Kp
        return proportional_Output


    # Deactivate thrust protection
    def DeactiveThrustProtection(self):
        for i in range(10):
            self._helper.cf.commander.send_setpoint(0, 0, 0, 0)


    # Gradually increase thurst levels from 20000 to 30000 with 500 steps
    def Ramp(self):
        thrust_step = 500
        thrust = 20000
        pitch = 0
        roll = 0
        yawrate = 0
        self.DeactiveThrustProtection()

        while thrust < 30000:
            self._helper.cf.commander.send_setpoint(-roll, pitch, yawrate, thrust)
            self.console.insertPlainText("R:" + str(roll) + " P:" + str(pitch) + " Y:" + str(yawrate) + " T:" + str(thrust) + "\n")
            time.sleep(0.2)
            thrust += thrust_step
        self.EndCommand()


    # Gradualy decrease thrust
    def Land(self, Roll , Pitch, Yaw, thrust):
        self.SaftyCheck()
        thrust = ConsoleTab.PID_Output[2]
        if ConsoleTab.SendCommands_Test:
            if thrust >= 35000:                                                                                         #Decrease thrust to Hover level
                thrust -= int(thrust * 0.002) + 2                                                                       #Decrease thrust
                self._helper.cf.commander.send_setpoint(-Roll, Pitch, 0, int(thrust))                                   #Send command
                self.progressBar.setValue(int((thrust / 60000) * 100))
                self.lblThrusty.setText(str(thrust))                                                                    #Update GUI with new thrust

            elif thrust >= 15500 and thrust < 35000:                                                                    #Decrease thrust to Land
                thrust -= int(thrust * 0.09) + 50
                self._helper.cf.commander.send_setpoint(-Roll, Pitch, 0, int(thrust))
                self.progressBar.setValue(int((thrust / 60000) * 100))
                self.lblThrusty.setText(str(thrust))

            elif thrust < 15500:                                                                                        #Send terminate command if thrust low or drone is unstable
                #self.EndCommand()
                self.Off.setChecked(True)
                ConsoleTab.Stage = 3
        ConsoleTab.PID_Output[2] = thrust


    # end drone operations
    def EndCommand(self):
        ''' End communications with the drone.
            Make sure that the last packet leaves before the link is closed
            since the message queue is not flushed before closing (Time.sleep)'''

        ConsoleTab.VTActivated = 0
        self._helper.cf.commander.send_setpoint(0, 0, 0, 0)
        self.lblThrusty.setText("0")
        self.progressBar.setValue(int((0 / 60000) * 100))
        time.sleep(0.1)
        self._helper.cf.commander.send_stop_setpoint()


    def _param_updated(self, name, value):
        """Callback when the registered parameter get's updated"""
        logger.debug("Updated {0} to {1}".format(name, value))


    #Send a command using ZMQ
    def ZMQCommand(self):
        self.progressBar2.setValue(0)
        context = zmq.Context()
        sender = context.socket(zmq.PUSH)
        bind_addr = "tcp://127.0.0.1:{}".format(1024 + 188)
        sender.connect(bind_addr)
        Thrust = int(self.TEDThrust.toPlainText())
        roll = int(self.TEDRoll.toPlainText())
        Pitch = int(self.TEDPitch.toPlainText())
        Yaw = int(self.TEDYaw.toPlainText())

        cmdmess = {
            "version": 1,
            "ctrl": {
                "roll": 0.0,
                "pitch": 0.0,
                "yaw": 0.0,
                "thrust": 0.0
            }
        }
        self.progressBar2.setValue(25)

        # Unlocking thrust protection
        cmdmess["ctrl"]["thrust"] = 0
        sender.send_json(cmdmess)

        for i in range(10):
            cmdmess["ctrl"]["thrust"] = Thrust
            sender.send_json(cmdmess)
            time.sleep(0.5)

        self.progressBar2.setValue(50)

        for i in range(10):
            Thrust -= Thrust*0.1
            cmdmess["ctrl"]["thrust"] = Thrust
            sender.send_json(cmdmess)
            time.sleep(0.5)

        cmdmess["ctrl"]["thrust"] = 0
        sender.send_json(cmdmess)
        self.progressBar2.setValue(100)


    # Handles connetion to UDP stream (Recieving UDP stream)
    def ConnectToUDPStream(self):

        def BinderCoOrdinator(FinalMessagez):

            def getPort():
                Message = ""
                PortNumber = self.TxeditPort.toPlainText()
                if str(PortNumber) == "":
                    UDP_PORT_NO = 5000
                    Message += ("DEFAULT/" + str(UDP_PORT_NO))
                else:
                    UDP_PORT_NO = int(float(self.TxeditPort.toPlainText()))
                    Message += str(UDP_PORT_NO)
                return UDP_PORT_NO, Message

            def getaddress():
                ## IP Address Set
                index = self.IPAddressSelect.currentIndex()
                Message = ""
                if index == 0:
                    Message += "LocalVMIP "
                    UDP_IP_ADDRESS = "127.0.0.1"
                elif index == 1:
                    Message += "ViconIP"
                    UDP_IP_ADDRESS = "255.255.255.255"
                else:
                    Message += "Error>>>:Default IP used: LocalVMIP "
                    UDP_IP_ADDRESS = "127.0.0.1"
                return UDP_IP_ADDRESS, Message

            # IP address Set
            UDP_IP_ADDRESS, IPaddress = getaddress()
            # Port Number Set
            UDP_PORT_NO, IPPort = getPort()
            FinalMessagez += ("IP Name : " + IPaddress + '\n' + "Searching on Port : " + IPPort)

            #  Try to Bind
            if UDP_IP_ADDRESS == "255.255.255.255":  # Bind to vicon subnet
                clientSock = socket(AF_INET, SOCK_DGRAM)  # Socket
                clientSock.bind((UDP_IP_ADDRESS, UDP_PORT_NO))
                FinalMessagez += "\n" + "Bind successful"

            if UDP_IP_ADDRESS == "127.0.0.1":  # Bind to LocalHost
                try:
                    hostName = gethostbyname('0.0.0.0')
                    clientSock = socket(AF_INET, SOCK_DGRAM)  # Socket
                    clientSock.bind((hostName, UDP_PORT_NO))
                except error:
                    print("ERROR >>>:Unable to Bind with socket error :>>>" + str(error))
                    self.UDPCOnnectStatus.setText("Socket Time Out")
            return FinalMessagez, clientSock

        ##### find stream  #########################################
        FinalMessage,UDPSocket = BinderCoOrdinator("")
        self.UDPCOnnectStatus.setText("Socket Found")
        return UDPSocket


    #Receives stream, Parse data into variables, Parse variables into array for positions, Get average array
    def UDPDataCoordinator(self,clientSock):
        def GetUDPPacket(dataBlockSize, clientSock):
            try:
                clientSock.settimeout(0.02)  # to disable the vicon read for testing at home, comment the next line "recvfrom" and comment out Parse(data) and instead set all values to 0 "0,0,0,0,0,0,0,0,0"
                if ConsoleTab.activate_UDP_Test:
                    data, addr = clientSock.recvfrom(dataBlockSize)  # Get all the Vicon data
                    clientSock.close()  # Dont need the Socket open anymore
                    FrameNumber, Itemsinblock, ItemNamez, TransX, TransY, TransZ, RotX, RotY, RotZ = self.Parse(data)  # Parse the Data into usable data types
                else:
                    FrameNumber, Itemsinblock, ItemNamez, TransX, TransY, TransZ, RotX, RotY, RotZ = -1,-1,-1,-1,-1,-1,-1, -1, -1

            except error:

                if ConsoleTab.ComCounter <= 5:
                    self.console.insertPlainText("\nERROR >>>:Time Out with socket error :>>>\n" + str(error))
                    self.UDPCOnnectStatus.setText("Not Connected to Network")
                else:
                    self.console.insertPlainText("\nDefaulted\n")

                FrameNumber, Itemsinblock, ItemNamez, TransX, TransY, TransZ, RotX, RotY, RotZ = Defaulted()

            return FrameNumber, Itemsinblock, ItemNamez, TransX, TransY, TransZ, RotX, RotY, RotZ, clientSock

        def Defaulted():
            FrameNumber = 0
            Itemsinblock= 0
            ItemNamez= "Lost Connection"
            TransX = ConsoleTab.TransPositions[0,-1]
            TransY = ConsoleTab.TransPositions[1,-1]
            TransZ = ConsoleTab.TransPositions[2,-1]
            RotX = ConsoleTab.RotPositions[0, -1]
            RotY = ConsoleTab.RotPositions[1, -1]
            RotZ = ConsoleTab.RotPositions[2,-1]

            return FrameNumber, Itemsinblock, ItemNamez, TransX, TransY, TransZ, RotX, RotY, RotZ


        ##### Read UDP data ######################
        FrameNumber, Itemsinblock, ItemNamez, TransX, TransY, TransZ, RotX, RotY, RotZ, clientSock = GetUDPPacket(ConsoleTab.dataBlockSize,clientSock)

        if ConsoleTab.TransPositions[0,9]!= 0:
            TransX, TransY, TransZ, RotX, RotY, RotZ = self.Check_Data(TransX, TransY, TransZ, RotX, RotY, RotZ)

        counter = ConsoleTab.Counter                                #Add Values to global variable

        if counter == 10:                                            #End of list, begin sliding window
            #Array that holds all transitional positions
            ConsoleTab.TransPositions[0], ConsoleTab.TransPositions[1], ConsoleTab.TransPositions[2] = self.SlidingWindow(ConsoleTab.TransPositions[0] ,ConsoleTab.TransPositions[1],ConsoleTab.TransPositions[2],TransX,TransY,TransZ,1)

            # Array that holds all Rotational positions
            ConsoleTab.RotPositions[0], ConsoleTab.RotPositions[1], ConsoleTab.RotPositions[2] = self.SlidingWindow(ConsoleTab.RotPositions[0], ConsoleTab.RotPositions[1], ConsoleTab.RotPositions[2], RotX, RotY, RotZ, 1)

           ##############  Assign averages
            for i in range(3):
                ConsoleTab.AveragedRotPositions[i] = sum(ConsoleTab.RotPositions[i])/len(ConsoleTab.RotPositions[i])
                ConsoleTab.AveragedTransPositions[i] = sum(ConsoleTab.TransPositions[i]) /len(ConsoleTab.TransPositions[i])    # Average Trans X value
                #self.console.insertPlainText("\nAveraged Trans {}: \nTrans :{}".format(str(ConsoleTab.AveragedTransPositions[i]),str(ConsoleTab.TransPositions[i,-1])))
                if ConsoleTab.AveragedTransPositions[i] + 100 >  ConsoleTab.TransPositions[i,-1] or ConsoleTab.AveragedTransPositions[i] - 100 < ConsoleTab.TransPositions[i,-1] :
                    Hello = 0

        else:
            #Not end of list, add values
            ConsoleTab.TransPositions[0, counter] = TransX
            ConsoleTab.TransPositions[1, counter] = TransY
            ConsoleTab.TransPositions[2, counter] = TransZ
            ConsoleTab.RotPositions[0, counter] = RotX
            ConsoleTab.RotPositions[1, counter] = RotY
            ConsoleTab.RotPositions[2, counter] = RotZ

            ConsoleTab.Counter = counter + 1

        #Update GUI
        self.lblItemName.setText(str(ItemNamez))
        self.UDPX.setText(str(TransX))  # X
        self.UDPY.setText(str(TransY))  # Y
        self.UDPZ.setText(str(TransZ))  # Z

        # Rotation
        self.UDPTX.setText(str(round(RotX, 0)))
        self.UDPTY.setText(str(round(RotY, 0)))
        self.UDPTZ.setText(str(round(RotZ, 0)))


    #Checks data is not absurdly larger or smaller than the previous value
    def Check_Data(self,TransX, TransY, TransZ, RotX, RotY, RotZ,):
        Threshold = 1000
        TransX = self.Range(ConsoleTab.TransPositions[0,-1],TransX,Threshold)
        TransY = self.Range(ConsoleTab.TransPositions[1,-1], TransY, Threshold)
        TransZ =self.Range(ConsoleTab.TransPositions[2,-1], TransZ, Threshold)
        RotX = self.Range(ConsoleTab.RotPositions[0,-1], RotX, Threshold)
        RotY = self.Range(ConsoleTab.RotPositions[1,-1], RotY, Threshold)
        RotZ = self.Range(ConsoleTab.RotPositions[2,-1], RotZ, Threshold)
        return TransX, TransY, TransZ, RotX, RotY, RotZ


    # if a value is too far over the thresh hold it gets ignored and marked as an error if it evaluates as true then do not use value
    def Range(self, Previous, Current, Threshold):
        iThreshold = int(Threshold)
        if Current >= Previous + iThreshold or Current <= Previous - iThreshold:
            return Previous
        else:
            return Current


    # Subtracts the first value in the array from the total and then deletes it from the array, then adds last value added (New) to total (Average)
    def SlidingWindow(self, AverageX, AverageY, AverageZ, NewX, NewY, NewZ,Indication):
        if Indication == 1:                                         # Used for an array and int
            for i in range(len(AverageX) - 1):                      # Move all values down 1
                AverageX[i] = AverageX[i + 1]
                AverageY[i] = AverageY[i + 1]
                AverageZ[i] = AverageZ[i + 1]

            AverageX[len(AverageX) - 1] = NewX
            AverageY[len(AverageY) - 1] = NewY
            AverageZ[len(AverageZ) - 1] = NewZ

        if Indication == 2:                                         # Used for 2 arrays
            for i in range(len(AverageX)-1):
                AverageX[i] = AverageX[i + 1]
                AverageY[i] = AverageY[i + 1]
                AverageZ[i] = AverageZ[i + 1]

            AverageX[len(AverageX)-1] = np.sum(NewX)/len(NewX)
            AverageY[len(AverageY)-1] = np.sum(NewY)/len(NewY)
            AverageZ[len(AverageZ)-1] = np.sum(NewZ)/len(NewZ)

        return AverageX, AverageY, AverageZ


    def Summary(self):
        ConsoleTab.Stage = 2


    # Display the 3D Position of the drone
    def SummaryP(self):
        #self._helper.cf.commander.send_stop_setpoint()
        self.Writetofile("LogData", ConsoleTab.LogDataz)
        Target = []
        Clamppp = []
        Max= []
        min = []
        for i in range(len(ConsoleTab.KdOutput_Array)):
            Target.append(self.TEDZ.toPlainText())                                                                      # Desired position                                                                                  # Max Thrust, doesnt change
            Clamppp.append(ConsoleTab.MaxThrust)
            Max.append(ConsoleTab.MaxThrust)
            min.append(ConsoleTab.MinimumThrust)

        self.PlotAxis(ConsoleTab.TransPositions, Target, ConsoleTab.Time_log,Clamppp,Max,min)
        ConsoleTab.Stage = 4
        ConsoleTab.PIDInitialized = 0
        self.RBConnectUDP.setChecked(False)
        self.RB1Dimen.setChecked(False)


    # Plot the axis of the recoded data (Legacy)
    def PlotAxis(self,Positions, Target, Time1,Clamp,MxThrust,MnThrust):
        x_line = ConsoleTab.XPos
        y_line = ConsoleTab.YPos
        z_line = ConsoleTab.ZPos

        fig = plt.figure()
        #ax = plt.axes(projection = '3d')
        ax = fig.add_subplot(2,3,1,projection = '3d' )

        ax.plot3D(x_line,y_line,z_line,'gray')
        plt.xlabel('X - Position (mm)')
        plt.ylabel('Y - Position (mm)')
        ax.set_zlabel('Z - Position (mm)')
        ax.set_xlim3d(-1600, 3000)
        ax.set_ylim3d(-2000, 2000)
        ax.set_zlim3d(0, 2000)
        plt.title("Position")

        #plt.figure(2)
        plt.subplot(2,3,2)
        plt.title("Thrust Levels")
        plt.xlabel('X - Time (Sec)')
        plt.ylabel('Y - Max Thrust (mm)')

        X = np.array(ConsoleTab.ThrustValues)
        Timen = np.array(Time1)
        Clampn = np.array(Clamp)
        MaxThrustn = np.array(MxThrust)
        MinThrustn = np.array(MnThrust)
        plt.ylim(39000,ConsoleTab.Max_Output[2] + 1000 )
        plt.plot(Timen , X, label = "Thrust Command")
        plt.plot(Timen,MaxThrustn,  label = "Max Thrust")
        plt.plot(Timen,MinThrustn, label="Min Thrust")
        plt.legend( loc='best')

        plt.subplot(2, 3, 3)
        plt.title("Proportional")
        plt.xlabel('X - Time (Sec)')
        plt.ylabel('Y - Output ')
        X = np.array(ConsoleTab.KpOutput_Array)
        plt.ylim(min(ConsoleTab.KpOutput_Array) -500, max(ConsoleTab.KpOutput_Array) +500)
        plt.plot(Timen, X)
        plt.plot(Timen, Clampn, label="Clamp")
        plt.legend(loc='best')

        plt.subplot(2, 3, 4)
        plt.title("Integral")
        plt.xlabel('X - Time (Sec)')
        plt.ylabel('Y - Output ')
        X = np.array(ConsoleTab.KiOutput_Array)
        plt.ylim(min(ConsoleTab.KiOutput_Array) -100 , max(ConsoleTab.KiOutput_Array) +100)
        plt.plot(Timen, X)

        plt.subplot(2, 3, 5)
        plt.title("Derivetive")
        plt.xlabel('X - Time (Sec)')
        plt.ylabel('Y - Output ')
        plt.ylim(min(ConsoleTab.KdOutput_Array) - 100, max(ConsoleTab.KdOutput_Array) + 100 )
        X = np.array(ConsoleTab.KdOutput_Array)
        plt.plot(Timen, X)

        Time = []
        for i in range(len(z_line)):
            Time.append(ConsoleTab.Command[2])

        plt.subplot(2, 3, 6)
        plt.title("Z Pos Target :" +str(ConsoleTab.Command[2]))
        plt.xlabel('X - Time (Sec)')
        plt.ylabel('Y - Position ')
        z_line_np = np.array(z_line)
        Target_np = np.array(Target)
        Target_nppp = np.array(Time)
        plt.ylim(0,1800)
        plt.plot(Timen, z_line_np, label = "Measured" )
        plt.plot(Timen, Target_nppp, label="Command")
        #plt.plot(Timen, Target_np,  label = "Target")
        plt.legend(loc='best')

        plt.show()
        return


    #Write all the log data to a text file inside /home/bitcraze/Desktop/projects/crazyflie-clients-python/bin/"Name".txt
    def Writetofile(self,Name,Data):
        File_object = open(Name + ".txt", "w")
        File_object.write("\n" + str(ConsoleTab.StartTime) +"\n" )
        for i in range(60):
            args = (str(Data[i][0]),str(Data[i][1]) ,str(Data[i][2]) ,str(Data[i][3]) ,str(Data[i][4]) ,str(Data[i][5]) ,str(Data[i][6]) ,str(Data[i][7]) )
            DatatoWrite = ('|Thrust:{0:<2} Error:{1:<40}    |Roll:{2:<2} Error:{3:<40}    |Pitch:{4:<2} Error:{5:<40}   |Yaw:{6:<2} Error:{7:<40} '.format(*args))
            File_object.write("\n" + DatatoWrite)
        File_object.close()


    #Converts byte vicon data into datatype double
    def Unpack(self,Dataobj, start, end):
        # print(len(Dataobj[start:end]))
        Value, = struct.unpack('d', Dataobj[start:end])
        # print("Leng:", len(Dataobj[start:end]), "Byte :", Dataobj[start:end], "Value: ", Value)
        return Value


    # parse UDP datastream into variables
    def Parse(self, data):
        FrameNumber = int(data[1]) + int(data[2]) + int(data[3])
        Itemsinblock = int(data[4])
        ItemID = int(data[5])
        ItemDataSize = data[6:7]
        ItemNamez = data[8:30]
        TransX = round(self.Unpack(data, 32, 40),2)
        TransY = round(self.Unpack(data, 40, 48),2)
        TransZ = round(self.Unpack(data, 48, 56),2)
        RotX = round(self.Unpack(data, 56, 64),5)
        RotY = round(self.Unpack(data, 64, 72),5)
        RotZ = round(self.Unpack(data, 72, 80),5)
        return FrameNumber, Itemsinblock, ItemNamez, TransX, TransY, TransZ, RotX, RotY, RotZ


    # Converts the byte value obtained from UDP stream into usable data (Convert to string then int then store in variable)
    def TransCoverter(self, Low_Index, High_Index, data):
        finalvalue = 0
        holder = 0
        while Low_Index <= High_Index:
            holder = data[Low_Index]
            finalvalue += int(str(holder))
            Low_Index += 1
        return finalvalue


    ###### Initialize PID Variables
    def initPID2(self):
        ClientPID = self.CBOXPID.isChecked()
        IntCLamp = False
        commandVariableX = int(self.TEDX.toPlainText())
        commandVariableY = int(self.TEDY.toPlainText())
        commandVariableZ = int(self.TEDZ.toPlainText())
        errorTerm, PreviousError, intergralSum = 0, 0, 0
        # when the desired value is reached twice then boolDone = true and exit
        DoubleCheck = 0
        BoolDone = False

        '''Deactivate thrust proctection'''
        self.DeactiveThrustProtection()
        return roll, pitch, yawrate, thrust, ClientPID, IntCLamp, commandVariableX, commandVariableY, commandVariableZ, errorTerm, PreviousError, intergralSum, DoubleCheck, BoolDone


    def SlidingWindow_Simple(self,Array,NewValue):
        del Array[0]
        Array.append(NewValue)
        return Array


    def SlidingWindow_Simple_Numpy(self, Array, NewValue,Maxlen):
        Maxlen -= 1
        del Array[0]
        #for i in range(len(NewValue)-1):
        Array.append(NewValue)                                                                               # Add new value to end of the array
        return Array


    #change start time, and signal that the Virtual trajectory must now begin
    def VTActivator(self):
        if ConsoleTab.PIDInitialized==0:
            self.initPID()
            self.DeactiveThrustProtection()
            ConsoleTab.StartTime = datetime.datetime.now()
            ConsoleTab.PIDInitialized = 1
            if self.RB1Dimen.isChecked() == False:
                self.RB1Dimen.setEnabled(False)


#TODO: Determine which functions are no longer used below this point



    def AddtoAverage(PrevioT, Tran, Aver):
        BooT = Range(self, PrevioT, Tran)  # if too different dont use(assume noise)
        if BooT != False:
            Aver += Tran
        return Aver


    def PrintAllData(self, FrameNumber, Itemsinblock, ItemNamez, AverageTransX, AverageTransY, AverageTransZ,Moved, StartingPoint, Calibrated):
        if Calibrated == False:
            print("Frame Number :", FrameNumber, "TransX :", AverageTransX, " | ", "TransY :", AverageTransZ,
                  " | ",
                  "TransZ :", AverageTransY, " | ", "Moved:", Moved, " F")
        if Calibrated == True:
            print("Frame Number :", FrameNumber, "TransX :", AverageTransX, " | ", "TransY :", AverageTransZ,
                  " | ",
                  "TransZ :", AverageTransY, " | ", "Moved:", Moved, " | ", "Origin,", "X:", StartingPoint[0],
                  " Y:", StartingPoint[2], " Z:", StartingPoint[1])
        Printer = ""
        Printer = "\n" + "Frame Number :" + str(FrameNumber) + "\n" + "Transition " + "\n" + "X :" + str(
            AverageTransX) + " ," + "Y :" + str(AverageTransY) + " ," + "Z :" + str(
            AverageTransZ)
        return Printer


    def HasDroneMoved(self, PreviousTx, PreviousTy, PreviousTz, ActualAverageX, ActualAverageY, ActualAverageZ, Moved):
        if PreviousTx == 0:
            PreviousTx, PreviousTy, PreviousTz = ActualAverageX, ActualAverageY, ActualAverageZ
            Moved = True
        else:
            if ActualAverageX <= PreviousTx + 20 and ActualAverageX >= PreviousTx - 20 or \
                    ActualAverageY <= PreviousTy + 20 and ActualAverageY >= PreviousTy - 20 or \
                    ActualAverageZ <= PreviousTz + 20 and ActualAverageZ >= PreviousTz - 20:
                Moved = False
            else:
                Moved = True
            PreviousTx, PreviousTy, PreviousTz = ActualAverageX, ActualAverageY, ActualAverageZ
        return PreviousTx, PreviousTy, PreviousTz, Moved


    # Gets the origin of the drone
    def Calibrate(self, Calibrated, StartingPoint, SumsX, SumsY, SumsZ, ActualAverageX, ActualAverageY,ActualAverageZ):
        if len(SumsZ) >= 20 and Calibrated == False:
            X, Y, Z = 0, 0, 0
            # Use values 40 - 50 as the first couple of values will always be on the lower end of the deviation
            for i in range(10, 20):
                X += SumsX[i]
                Y += SumsY[i]
                Z += SumsZ[i]

            StartingPoint.append(X / 10)
            StartingPoint.append(Y / 10)
            StartingPoint.append(Z / 10)
            Calibrated = True
        else:
            SumsX.append(ActualAverageX)
            SumsY.append(ActualAverageY)
            SumsZ.append(ActualAverageZ)
            Calibrated = False
        return Calibrated, StartingPoint, SumsX, SumsY, SumsZ


    # average = ((sum of all (X,Y,Z values) / (length of array) / length of sliding window)
    def GetActualAverage(self, ActualAverageX, ActualAverageY, ActualAverageZ, TotalX, TotalY, TotalZ,windowSize):
        ActualAverageX = sum(TotalX) / len(TotalX) / windowSize
        ActualAverageY = sum(TotalY) / len(TotalY) / windowSize
        ActualAverageZ = sum(TotalZ) / len(TotalZ) / windowSize
        return ActualAverageX, ActualAverageY, ActualAverageZ


    def StandardD(Array):
        Sq = []
        mean = sum(Array) / len(Array)
        for i in range(len(Array)):
            Sq.append((Array[i] - mean) * (Array[i] - mean))

        newmean = sum(Sq) * (1 / len(Sq))
        print(newmean)
        deviation = math.sqrt(newmean)
        print(deviation)


    def OriginTranslator(ActualAverageX, ActualAverageY, ActualAverageZ, StartingPoint):
        ActualAverageX, ActualAverageY, ActualAverageZ = ActualAverageX - StartingPoint[0], ActualAverageY - \
                                                         StartingPoint[1], ActualAverageZ - StartingPoint[2]
        return ActualAverageX, ActualAverageY, ActualAverageZ


    def init():
        FinalMessage = ""  # Holds all logging information monitored, displayed at the end of execution in client
        self.clear()
        self.progressBar.setValue(0)
        Writetofile1("Start")  # begin logging
        Moved = False  # Has drone moved ?
        ProgressBar, PreviousTx, PreviousTy, PreviousTz = 0, 0, 0, 0  # Used to determine if drone has moved
        PosY = 0  # Used for traversal of Y axis (Holds sliding window pos)
        AverageTransX, AverageTransY, AverageTransZ, AverageRotX, AverageRotY, AverageRotZ = 0, 0, 0, 0, 0, 0
        ActualAverageX, ActualAverageY, ActualAverageZ = 1000, 1000, 1000
        # all thrust levels, all pos, time
        ThrustLevels = []
        Positions = []
        Time = []
        TimeVar = 0
        windowSize = 50  # Sliding window size
        # Contain all respective actual values
        ArrayTransX = []
        ArrayTransY = []
        ArrayTransZ = []
        # holds the averages to be used to calculate the starting point
        SumsX = []
        SumsY = []
        SumsZ = []
        StartingPoint = []  # Holds the orgin values,[0]=x [1]=y [2]=z
        Calibrated = False
        AlteredCommand = False  # Used to alter the command variables into resonable data
        CommandCounter = 0  # Counts commands sent

        return FinalMessage, Moved, ProgressBar, PreviousTx, PreviousTy, PreviousTz, PosY, \
               AverageTransX, AverageTransY, AverageTransZ, AverageRotX, AverageRotY, AverageRotZ, \
               ActualAverageX, ActualAverageY, ActualAverageZ, ThrustLevels, Positions, Time, \
               TimeVar, windowSize, ArrayTransX, ArrayTransY, ArrayTransZ, SumsX, SumsY, \
               SumsZ, StartingPoint, Calibrated, AlteredCommand, CommandCounter


    def MonitorValues(self,ClientPID, Calibrated, commandVariableX, commandVariableY, commandVariableZ,AverageTransX,AverageTransY, AverageTransZ, thrust, CommandCounter, errorTerm):
        if ClientPID == False and Calibrated == True:
            FinalMessage += "\n" + "Desired Pos :" + "X" + str(commandVariableX) + " Y" + str(
                commandVariableY) + " Z" + str(commandVariableZ) + "\n" + "Current :" + str(
                AverageTransX) + str(AverageTransY) + str(AverageTransZ)
        else:
            FinalMessage += "\n" + "Desired Pos :" + "X" + str(commandVariableX) + " Y" + str(
                commandVariableY) + " Z" + str(commandVariableZ) + "\n" + "Current :" + str(
                AverageTransX) + str(AverageTransY) + str(AverageTransZ)
            FinalMessage += "\n" + "Thrust levels :" + str(thrust) + "  Loops :" + str(
                CommandCounter) + " Error :" + str(errorTerm)
            FinalMessage += "\n" + "--------------" + "\n"

            # Time Out
        if CommandCounter == 160:
            self.progressBar2.setValue(1)
            Land(self, thrust)
            BoolDone = True
        return BoolDone


    def DronePID(self,ActualAverageX, ActualAverageY, ActualAverageZ, StartingPoint, commandVariableX,commandVariableY,commandVariableZ):
        yaw = 0

        # Fix vicon calibration by setting origin manually
        ActualAverageX, ActualAverageY, ActualAverageZ = OriginTranslator(ActualAverageX, ActualAverageY,
                                                                          ActualAverageZ, StartingPoint)

        # Send the position of the drone obtained through vicon udp, external pos must be in meters hence /1000,swap Z and Y due to calibration issues
        self._helper.cf.extpos.send_extpos(ActualAverageX / 1000, ActualAverageZ / 1000, ActualAverageY / 1000)  # Z+1.5 ?

        # Send Command
        self._helper.cf.commander.send_position_setpoint(commandVariableX, commandVariableY, commandVariableZ,yaw)
        return


    def EndConnect(self, FinalMessage, Time, commandVariableY, ThrustLevels, Positions):
        self.console.setText(FinalMessage)
        clientSock.close()
        self.progressBar.setValue(100)
        Target = []
        Locked = []
        for i in range(len(Time)):
            Target.append(commandVariableY)  # Desired position
            Locked.append(60000)  # Max Thrust, doesnt change
        PlotAxis(ThrustLevels, Positions, Target, Locked, Time)
        return


    #####################################################################################################################################################################################
    def ConnectUDP1(self):
        ##### Initialize Variables ####################################
        FinalMessage, Moved,
        ThrustLevels, Positions, Time, TimeVar,  \
        StartingPoint, Calibrated, AlteredCommand, CommandCounter = init()

        ##### Initialize PID Variables ################################
        thrust, ClientPID, IntCLamp, commandVariableX, commandVariableY, commandVariableZ, errorTerm, PreviousError, intergralSum, DoubleCheck, BoolDone = initPID()

        ## Main #######################################################
        self.console.setText("Calibrating origin, This may take up to 20 seconds")
        while BoolDone == False:
            self.progressBar.setValue(int((thrust / 60000) * 100))

            TotalX = []
            TotalY = []
            TotalZ = []
            # get the average value of each variable after 50 iterations
            while len(TotalX) < windowSize:
                ##### 1 read Gyro values #################################
                roll, pitch, yawrate = EatGyro()

                ##### Send command to drone every 10th iteration ########
                ThrustLevels, Time, TimeVar, Positions = SendCommand(TotalX, thrust, TimeVar, ThrustLevels, Time,
                                                                     Positions, TotalY, roll, pitch, yawrate, PosY)

                ##### Sliding window operation ##########################
                AverageTransX, AverageTransY, AverageTransZ, ArrayTransX, ArrayTransY, ArrayTransZ, TotalX, TotalY, TotalZ = AddtoWindow(
                    AverageTransX, AverageTransY, AverageTransZ, ArrayTransX, ArrayTransY, ArrayTransZ, windowSize,
                    TransX, TransY, TransZ, TotalX, TotalY, TotalZ)

                ##### Contains sliding window average of Y###############
                PosY = AverageTransY / windowSize

            # average = ((sum of all (X,Y,Z values) / (length of array) / length of sliding window)
            ActualAverageX, ActualAverageY, ActualAverageZ = GetActualAverage(self, ActualAverageX, ActualAverageY,
                                                                              ActualAverageZ, TotalX, TotalY,
                                                                              TotalZ, windowSize)

            #### work out if drone has moved ############################
            PreviousTx, PreviousTy, PreviousTz, Moved = HasDroneMoved(self, PreviousTx, PreviousTy, PreviousTz,
                                                                      ActualAverageX, ActualAverageY,
                                                                      ActualAverageZ, Moved)

            # get Starting Point ########################################
            if Calibrated == False:
                Calibrated, StartingPoint, SumsX, SumsY, SumsZ = Calibrate(self, Calibrated, StartingPoint, SumsX,
                                                                           SumsY, SumsZ, ActualAverageX,
                                                                           ActualAverageY, ActualAverageZ)

            # Print all data, *remember that Y = Z , Z= Y
            FinalMessage += ("\n" + "Address : " + UDP_IP_ADDRESS) + PrintAllData(self, FrameNumber, Itemsinblock,
                                                                                  ItemNamez, int(ActualAverageX),
                                                                                  int(ActualAverageY),
                                                                                  int(ActualAverageZ), Moved,
                                                                                  StartingPoint, Calibrated)

            ############### Translate command ############################
            # basically, if the actual origin position is 800 and a command of 100 is sent then the drone moves
            # 100 in that axis so 900 final pos
            if Calibrated == True and AlteredCommand == False:
                commandVariableX, commandVariableY, commandVariableZ = commandVariableX + StartingPoint[
                    0], commandVariableY + StartingPoint[1], commandVariableZ + StartingPoint[2]
                AlteredCommand = True

            #### Start client PID loop ###################################
            if Calibrated == True and ClientPID == True:
                BoolDone, thrust, intergralSum, IntCLamp, ProgressBar, errorTerm = ClientPID(ActualAverageX, PosY,
                                                                                             ActualAverageZ,
                                                                                             errorTerm,
                                                                                             commandVariableY,
                                                                                             ProgressBar, thrust,
                                                                                             intergralSum, IntCLamp,
                                                                                             PreviousError,
                                                                                             BoolDone)

            #### Send external Pos and commands to Drone##################
            elif Calibrated == True and ClientPID == False:
                DronePID(ActualAverageX, ActualAverageY, ActualAverageZ, StartingPoint, commandVariableX,
                         commandVariableY, commandVariableZ)

            #### Monitor values and determine if program must timeout ####
            CommandCounter += 1
            BoolDone = MonitorValues(ClientPID, Calibrated, commandVariableX, commandVariableY, commandVariableZ,
                                     AverageTransX, AverageTransY, AverageTransZ, thrust, CommandCounter, errorTerm)

            # Display all data obtained and close #############################
        EndConnect(FinalMessage, Time, commandVariableY, ThrustLevels, Positions)

        ################################################################################################################################################################################################



